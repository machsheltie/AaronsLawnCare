# Expanded Detailed Instructions for Dyad

1. **Initialize a new React 18 project using Vite with TypeScript template and name it 'aarons-lawn-care'**

Run `npm create vite@latest aarons-lawn-care -- --template react-ts` in your terminal to scaffold a React 18.2+ project with TypeScript support, hot module replacement, and optimized build configuration. Navigate into the project directory with `cd aarons-lawn-care` and run `npm install` to install all base dependencies including react@18.2.0, react-dom@18.2.0, vite@5.0.0, and typescript@5.0.0. Open the project in your code editor and verify that vite.config.ts exists with the React plugin configured, tsconfig.json has strict mode enabled with "target": "ES2020" and "moduleResolution": "bundler", and the src directory contains main.tsx as the entry point. Delete the default src/App.css and src/index.css files as we'll be using Tailwind CSS exclusively for styling, and remove all boilerplate code from App.tsx leaving only an empty component that returns a div with "Hello World" for now.

2. **Install Tailwind CSS v3.4+ with PostCSS and configure it with mobile-first breakpoints**

Run `npm install -D tailwindcss@3.4.1 postcss@8.4.33 autoprefixer@10.4.17` to install Tailwind CSS and its peer dependencies, then run `npx tailwindcss init -p` to generate both tailwind.config.js and postcss.config.js files in the project root. In tailwind.config.js, set the content array to `["./index.html", "./src/**/*.{js,ts,jsx,tsx}"]` to enable Tailwind to scan all your component files for class names, and configure the theme.extend object with custom breakpoints: `screens: { 'xs': '475px', 'sm': '640px', 'md': '768px', 'lg': '1024px', 'xl': '1280px', '2xl': '1536px' }` ensuring mobile-first responsive design where styles apply from smallest to largest screen. Create a new file src/index.css and add the three Tailwind directives: `@tailwind base;`, `@tailwind components;`, and `@tailwind utilities;` on separate lines, then import this file at the top of src/main.tsx with `import './index.css'` to inject Tailwind's styles into your application. Test the installation by adding className="bg-blue-500 text-white p-4" to the div in App.tsx and verifying that blue background, white text, and 16px padding render correctly when running `npm run dev`.

3. **Install React Router DOM v6 for routing and navigation**

Run `npm install react-router-dom@6.21.0` to install the latest stable version of React Router v6 which provides declarative routing, nested routes, and programmatic navigation for single-page applications. Import BrowserRouter, Routes, and Route from 'react-router-dom' at the top of src/main.tsx, then wrap the App component with `<BrowserRouter>` to enable routing context throughout the application, ensuring basename prop is set to "/" for root-level deployment. Create a basic route structure in App.tsx by importing Routes and Route, then define at least three routes: a home route with `<Route path="/" element={<div>Home</div>} />`, a login route with path="/login", and a wildcard route with path="*" for 404 handling that displays "Page Not Found" text. Verify routing works by running the dev server with `npm run dev`, navigating to http://localhost:5173/ and http://localhost:5173/login in your browser, confirming both routes render their respective content, and test the 404 route by navigating to http://localhost:5173/nonexistent-page to ensure proper fallback behavior.

4. **Install Zustand for client-side state management**

Run `npm install zustand@4.4.7` to install Zustand, a lightweight state management library that uses hooks and requires zero boilerplate compared to Redux while providing excellent TypeScript support and devtools integration. Create a new directory src/stores and add a test store file src/stores/counterStore.ts with the following pattern: `import { create } from 'zustand'; interface CounterState { count: number; increment: () => void; decrement: () => void; } export const useCounterStore = create<CounterState>((set) => ({ count: 0, increment: () => set((state) => ({ count: state.count + 1 })), decrement: () => set((state) => ({ count: state.count - 1 })) }));` to demonstrate proper TypeScript typing and Zustand's immutable state update pattern using the set function. In App.tsx, import and use the store with `const { count, increment } = useCounterStore()` and render the count value with an increment button to verify the store works correctly, ensuring re-renders happen only when subscribed state changes. For production stores, always define clear TypeScript interfaces, use shallow comparison with `create<State>()(...)` for better performance, and consider adding devtools middleware with `import { devtools } from 'zustand/middleware'` and wrapping your store creator with `devtools(...)` for Redux DevTools integration during development.

5. **Install TanStack Query (React Query v5) for server state management**

Run `npm install @tanstack/react-query@5.17.0 @tanstack/react-query-devtools@5.17.0` to install React Query v5 which handles server state caching, background refetching, automatic retries, optimistic updates, and request deduplication with zero configuration required. In src/main.tsx, import QueryClient and QueryClientProvider from '@tanstack/react-query', create a new QueryClient instance with configuration: `const queryClient = new QueryClient({ defaultOptions: { queries: { staleTime: 60 * 1000, cacheTime: 5 * 60 * 1000, retry: 1, refetchOnWindowFocus: false } } })` setting 60-second stale time, 5-minute cache time, single retry on failure, and disabled refetch on window focus for better mobile performance. Wrap your App component in main.tsx with `<QueryClientProvider client={queryClient}>` and add the ReactQueryDevtools component with `import { ReactQueryDevtools } from '@tanstack/react-query-devtools'` and `<ReactQueryDevtools initialIsOpen={false} position="bottom-right" />` as the last child inside the provider for debugging query states during development. Create a test query in App.tsx using `const { data, isLoading, error } = useQuery({ queryKey: ['test'], queryFn: async () => { await new Promise(resolve => setTimeout(resolve, 1000)); return 'Hello Query'; } })` to verify queries work correctly and the devtools panel appears in the bottom-right corner showing query status, cache, and refetch controls.

6. **Install React Hook Form and Zod for form handling and validation**

Run `npm install react-hook-form@7.49.0 zod@3.22.4 @hookform/resolvers@3.3.4` to install React Hook Form for performant form state management with uncontrolled inputs, Zod for runtime TypeScript-first schema validation, and the resolvers package to integrate Zod schemas with React Hook Form validation. Create a new file src/lib/schemas.ts and define a test schema with `import { z } from 'zod'; export const loginSchema = z.object({ email: z.string().email('Invalid email address'), password: z.string().min(8, 'Password must be at least 8 characters') });` establishing runtime validation rules that also provide automatic TypeScript type inference. In App.tsx, create a test form using `import { useForm } from 'react-hook-form'; import { zodResolver } from '@hookform/resolvers/zod';` and initialize with `const { register, handleSubmit, formState: { errors } } = useForm({ resolver: zodResolver(loginSchema) });` then create form inputs with `<input {...register('email')} className="border p-2" />` and display validation errors with `{errors.email && <span className="text-red-500">{errors.email.message}</span>}` ensuring error messages appear in red text below each invalid field. Test the form by submitting with invalid data (email without @, password under 8 chars) and verify that Zod validation errors appear immediately with specific messages, then submit with valid data and confirm the onSubmit handler receives properly typed data with TypeScript autocomplete working for `data.email` and `data.password` properties.

7. **Install date-fns for date manipulation and formatting**

Run `npm install date-fns@3.0.6` to install date-fns, a modular date utility library with 200+ pure functions that offers tree-shaking for minimal bundle size, immutable operations, and TypeScript support without requiring moment.js's 67KB gzipped size. Import commonly needed functions at the top of any component with `import { format, parseISO, addDays, startOfWeek, endOfWeek, isToday, isTomorrow, formatDistanceToNow } from 'date-fns';` to handle date formatting, parsing ISO strings from database timestamps, adding/subtracting days, calculating week boundaries, checking date relationships, and displaying relative times like "2 hours ago". Create a test file src/lib/dateUtils.ts with helper functions like `export const formatJobDate = (date: string) => format(parseISO(date), 'MMM dd, yyyy')` for consistent date formatting (e.g., "Oct 16, 2025"), `export const formatJobTime = (time: string) => format(parseISO(`2000-01-01T${time}`), 'h:mm a')` for 12-hour time display (e.g., "9:00 AM"), and `export const getWeekRange = () => ({ start: startOfWeek(new Date()), end: endOfWeek(new Date()) })` for calendar week calculations. In App.tsx, test these utilities by importing them and displaying formatted dates with `<div>{formatJobDate('2025-10-16')}</div>` and `<div>{formatDistanceToNow(parseISO('2025-10-16T09:00:00'), { addSuffix: true })}</div>` to verify proper date parsing and formatting, ensuring dates display in user-friendly formats throughout the application with consistent formatting that respects the user's locale.

8. **Install lucide-react for icons**

Run `npm install lucide-react@0.292.0` to install Lucide Icons, a fork of Feather Icons with 1000+ consistent, customizable SVG icons optimized for React with tree-shaking support ensuring only imported icons add to bundle size (approximately 1KB per icon). Import specific icons at the top of any component with named imports like `import { Calendar, MapPin, Phone, Mail, ChevronRight, Plus, Check, X, AlertCircle, Loader2 } from 'lucide-react';` to use icons for calendar displays, location markers, contact actions, navigation chevrons, add buttons, success/error states, alerts, and loading spinners throughout the application. Render icons as React components with size and color props: `<Calendar className="w-5 h-5 text-gray-600" />` for 20px square icons in gray color, `<Loader2 className="w-4 h-4 animate-spin text-white" />` for 16px spinning loader in white color using Tailwind's animate-spin utility, and `<Plus className="w-6 h-6" strokeWidth={2.5} />` for 24px icons with thicker 2.5px stroke width for better visibility. Create a centralized icon component file src/components/ui/Icon.tsx that accepts an `icon` prop and size variants: `type IconProps = { icon: LucideIcon; size?: 'sm' | 'md' | 'lg'; className?: string; }; const sizes = { sm: 'w-4 h-4', md: 'w-5 h-5', lg: 'w-6 h-6' };` wrapping icons with consistent sizing throughout the app, and test by rendering various icons in App.tsx with different sizes and colors to ensure they display correctly at 16px/20px/24px respectively and maintain crisp edges at all screen densities.

9. **Install recharts for data visualization in reports**

Run `npm install recharts@2.10.3` to install Recharts, a composable charting library built with React components and D3 that provides responsive charts, animations, and supports line charts, bar charts, pie charts, and area charts needed for revenue reports and job completion analytics. Import chart components with `import { LineChart, Line, BarChart, Bar, PieChart, Pie, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, Cell } from 'recharts';` and always wrap charts in ResponsiveContainer with `<ResponsiveContainer width="100%" height={300}>` to ensure charts adapt to container width and maintain 300px height on mobile devices. Create a test chart in App.tsx with sample data: `const data = [{ name: 'Mon', jobs: 4 }, { name: 'Tue', jobs: 7 }, { name: 'Wed', jobs: 5 }];` then render a bar chart with `<BarChart data={data}><CartesianGrid strokeDasharray="3 3" /><XAxis dataKey="name" /><YAxis /><Tooltip /><Bar dataKey="jobs" fill="#10b981" /></BarChart>` using the primary green color (#10b981) for bars, dashed grid lines with 3px dash and 3px gap pattern, and including X/Y axes with tooltip on hover. For production charts, implement custom tooltip components with `<Tooltip content={<CustomTooltip />} />` where CustomTooltip formats currency as "$XXX.XX", dates as "MMM DD", and job counts as integers, ensure all charts have minimum height of 250px on mobile and 350px on desktop using Tailwind's h-[250px] md:h-[350px] classes, and add loading skeletons with `{isLoading ? <Skeleton className="h-[300px]" /> : <ResponsiveContainer>...</ResponsiveContainer>}` to prevent layout shift during data fetching.

10. **Install Dexie.js for IndexedDB offline storage**

Run `npm install dexie@3.2.4` to install Dexie.js, a minimalistic wrapper for IndexedDB that provides a simple API with promises, complex queries, and automatic schema management for offline-first Progressive Web App functionality. Create src/lib/db.ts and initialize the database with `import Dexie, { Table } from 'dexie'; export class AaronsLawnCareDB extends Dexie { jobs!: Table<Job>; customers!: Table<Customer>; photos!: Table<Photo>; offlineQueue!: Table<OfflineAction>; constructor() { super('AaronsLawnCareDB'); this.version(1).stores({ jobs: 'id, customer_id, scheduled_date, status, assigned_to', customers: 'id, phone, email', photos: '++id, job_id, uploaded', offlineQueue: '++id, action, timestamp' }); } } export const db = new AaronsLawnCareDB();` defining indexed columns for fast queries and auto-incrementing IDs with ++ prefix. Create offline queue functions in the same file: `export async function queueAction(action: { type: string; payload: any; timestamp: number }) { await db.offlineQueue.add(action); }` for storing failed API calls when offline, and `export async function syncOfflineQueue() { const queue = await db.offlineQueue.toArray(); for (const item of queue) { try { await processAction(item); await db.offlineQueue.delete(item.id!); } catch (error) { console.error('Sync failed:', error); } } }` for processing queued actions when connection restored. Test the database by importing db in App.tsx and adding test data with `await db.jobs.add({ id: '1', title: 'Test Job', scheduled_date: '2025-10-16' })` then querying with `const jobs = await db.jobs.where('scheduled_date').equals('2025-10-16').toArray()` to verify IndexedDB storage works correctly, and implement a useEffect hook that calls syncOfflineQueue() when window.navigator.onLine becomes true after being false.

11. **Install browser-image-compression for photo compression**

Run `npm install browser-image-compression@2.0.2` to install a client-side image compression library that reduces photo file sizes by 60-90% using canvas-based compression with web workers for non-blocking UI, supporting JPEG/PNG/WebP formats needed for before/after job photos. Create src/lib/imageUtils.ts with compression function: `import imageCompression from 'browser-image-compression'; export async function compressPhoto(file: File): Promise<File> { const options = { maxSizeMB: 0.5, maxWidthOrHeight: 1920, useWebWorker: true, fileType: 'image/webp', initialQuality: 0.85 }; try { const compressedFile = await imageCompression(file, options); console.log('Original:', (file.size / 1024 / 1024).toFixed(2), 'MB'); console.log('Compressed:', (compressedFile.size / 1024 / 1024).toFixed(2), 'MB'); return compressedFile; } catch (error) { console.error('Compression failed:', error); return file; } }` that compresses images to maximum 500KB size, 1920px width/height maintaining aspect ratio, converts to WebP format for 25-35% better compression than JPEG, uses 85% quality for optimal size/quality balance, and falls back to original file if compression fails. Create a test file input in App.tsx with `<input type="file" accept="image/*" onChange={async (e) => { const file = e.target.files?.[0]; if (file) { const compressed = await compressPhoto(file); console.log('Size reduction:', ((1 - compressed.size / file.size) * 100).toFixed(1), '%'); } }} />` and test by selecting a large photo (3-10MB) from your device, checking the console logs to verify compression reduces size by 70-90% (e.g., 8MB → 0.4MB), and confirming the compressed image maintains visual quality when displayed with URL.createObjectURL(). For production use, add progress callback with `onProgress: (progress) => setUploadProgress(progress)` in options object to display compression progress from 0-100%, handle errors with try/catch showing user-friendly messages like "Failed to compress photo, using original", and ensure maximum file size validation before compression with `if (file.size > 10 * 1024 * 1024) throw new Error('Photo must be under 10MB')`.

12. **Create a Supabase project in US East region named 'aarons-lawn-care'**

Navigate to https://app.supabase.com and sign in with your GitHub account or email, then click "New project" button in the dashboard to start project creation wizard. Enter "aarons-lawn-care" as the project name (lowercase with hyphens, no spaces or special characters), select "US East (N. Virginia)" from the region dropdown to minimize latency for Louisville, Kentucky users (~500 miles away providing sub-50ms response times), generate a strong database password using the auto-generate button and save it securely in your password manager (password must be at least 12 characters with uppercase, lowercase, numbers, and symbols), and choose the free tier pricing plan which includes 500MB database, 1GB file storage, and 50,000 monthly active users sufficient for MVP deployment. Wait 2-3 minutes for project provisioning while Supabase creates your PostgreSQL database instance, sets up authentication services, configures storage buckets, and initializes the API gateway, then verify project is ready when the dashboard displays "Project is ready" status in green with API settings showing your project URL (format: https://xxxxxxxxxxxxx.supabase.co) and anon public key (starts with "eyJ"). Copy both the project URL and anon key to a secure temporary location (text file, note app) as you'll need these in the next step for environment variable configuration, and click through to the SQL Editor tab to confirm database connectivity by running `SELECT NOW();` which should return the current UTC timestamp proving database is online and accepting queries.

13. **Copy the Supabase project URL and anon key to environment variables**

In your Supabase project dashboard, navigate to Settings → API section using the left sidebar menu and locate two critical values: the Project URL at the top showing your unique Supabase endpoint (format: https://abcdefghijklmnop.supabase.co), and the anon public key in the "Project API keys" section under "anon public" which is a long JWT token starting with "eyJ" that enables client-side authenticated requests. Open your code editor and create a new file named `.env.local` in the project root directory (same level as package.json and vite.config.ts), then add two environment variables on separate lines: `VITE_SUPABASE_URL=https://your-project-ref.supabase.co` and `VITE_SUPABASE_ANON_KEY=your-anon-key-here` replacing the placeholder values with your actual project URL and anon key copied from the dashboard, ensuring no quotes around values, no spaces before/after the equals sign, and VITE_ prefix is included as Vite only exposes environment variables starting with VITE_ to the client bundle. Add `.env.local` to your .gitignore file on a new line to prevent accidentally committing sensitive keys to version control (critical security requirement), create `.env.example` file with the same variable names but placeholder values like `VITE_SUPABASE_URL=your_supabase_url_here` and `VITE_SUPABASE_ANON_KEY=your_supabase_anon_key_here` to document required environment variables for other developers, and restart your Vite dev server with `npm run dev` since Vite only reads .env files at server startup and changes won't take effect until restart. Test environment variables are loaded correctly by adding `console.log(import.meta.env.VITE_SUPABASE_URL)` in App.tsx which should log your Supabase URL when the page loads, confirming environment configuration is working before proceeding with Supabase client initialization.

14. **Install @supabase/supabase-js v2.38+ client library**

Run `npm install @supabase/supabase-js@2.38.6` to install the official Supabase JavaScript client library that provides TypeScript-first SDK for authentication, database queries via PostgREST, realtime subscriptions, storage operations, and Edge Functions with automatic type generation from your database schema. Verify installation by checking package.json shows "@supabase/supabase-js": "^2.38.6" in dependencies, and confirm TypeScript types are automatically included by hovering over Supabase imports in VS Code which should show full type definitions and autocomplete suggestions. Create a test import in App.tsx with `import { createClient } from '@supabase/supabase-js'` and verify no TypeScript errors appear, then temporarily test client creation with `const supabase = createClient(import.meta.env.VITE_SUPABASE_URL, import.meta.env.VITE_SUPABASE_ANON_KEY)` followed by a simple query like `const { data, error } = await supabase.from('_test_').select('*')` which should fail gracefully with "relation _test_ does not exist" error message proving client successfully connects to Supabase but table doesn't exist yet (expected behavior at this stage). For production setup, ensure package.json uses caret (^) version range allowing minor and patch updates but not major version changes (e.g., ^2.38.6 allows 2.38.7 and 2.39.0 but not 3.0.0), and note that Supabase client is ~50KB gzipped and includes full TypeScript definitions for database types which will be generated later after creating database schema using `supabase gen types typescript` command.

15. **Create .env.local file with VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY**

Create a new file named `.env.local` in your project root directory (same level as package.json, vite.config.ts, and index.html) and add exactly two lines with no comments or extra whitespace: `VITE_SUPABASE_URL=https://xxxxxxxxxxxxx.supabase.co` on line 1 and `VITE_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...` on line 2, replacing the placeholder values with your actual Supabase project URL and anon key from step 13, ensuring the VITE_ prefix is present on both variable names (critical for Vite to expose them to client-side code) and there are no quotes, spaces, or trailing characters. Open your .gitignore file and add `.env*.local` on a new line if not already present (Vite scaffolding usually includes this) to prevent committing environment variables containing sensitive keys to Git version control, which would expose your Supabase credentials if pushing to public GitHub repository and require key rotation in Supabase dashboard settings. Create a companion `.env.example` file with identical variable names but placeholder values: `VITE_SUPABASE_URL=your_supabase_project_url` and `VITE_SUPABASE_ANON_KEY=your_supabase_anon_key`, commit this example file to Git with `git add .env.example && git commit -m "Add environment variables template"` to document required configuration for team members and deployment platforms like Vercel. Restart your development server completely (Ctrl+C to stop, then `npm run dev` again) since Vite only reads .env files during server initialization and hot module replacement won't pick up new environment variables, then verify variables load correctly by temporarily logging them in App.tsx with `console.log('Supabase URL:', import.meta.env.VITE_SUPABASE_URL)` which should print your full Supabase URL in browser console (remove this console.log after verification), and confirm TypeScript recognizes these variables by hovering over `import.meta.env.VITE_SUPABASE_URL` in VS Code which should show type `string` not `string | undefined`.

16. **Create src/lib/supabase.js file and initialize Supabase client with environment variables**

Create a new directory `src/lib` and inside it create `supabase.ts` (using TypeScript extension for type safety) with the following exact code structure: `import { createClient } from '@supabase/supabase-js'; const supabaseUrl = import.meta.env.VITE_SUPABASE_URL; const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY; if (!supabaseUrl || !supabaseAnonKey) { throw new Error('Missing Supabase environment variables'); } export const supabase = createClient(supabaseUrl, supabaseAnonKey);` which creates a singleton Supabase client instance with environment variable validation, throwing early error if variables undefined preventing cryptic runtime errors later. Add type safety by creating Database types: install Supabase CLI with `npm install -D supabase@1.142.2`, then after database schema is created in later steps, generate types with `npx supabase gen types typescript --project-id your-project-ref > src/lib/database.types.ts` and update supabase.ts to import types with `import { Database } from './database.types'; export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey)` giving full TypeScript autocomplete for table names, column names, and return types. Test the client works by importing it in App.tsx with `import { supabase } from './lib/supabase'` and running a test query in useEffect: `useEffect(() => { supabase.auth.getSession().then(({ data, error }) => { console.log('Supabase connected:', !error); }); }, []);` which should log "Supabase connected: true" in console proving successful initialization. Add configuration options for better performance: `createClient(supabaseUrl, supabaseAnonKey, { auth: { persistSession: true, autoRefreshToken: true, detectSessionInUrl: true }, global: { headers: { 'x-application-name': 'aarons-lawn-care' } } })` enabling automatic session persistence in localStorage, token refresh before expiry, magic link detection in URL, and custom header for API analytics, and ensure this file exports only the configured client instance to maintain single source of truth across entire application.

17. **Create src/lib/utils.js with cn() function for className merging using clsx**

Run `npm install clsx@2.0.0 tailwind-merge@2.2.0` to install clsx for conditional className joining and tailwind-merge for intelligently merging Tailwind classes (e.g., "p-4 p-6" → "p-6" keeping only the last padding value), then create `src/lib/utils.ts` with exactly this implementation: `import { type ClassValue, clsx } from 'clsx'; import { twMerge } from 'tailwind-merge'; export function cn(...inputs: ClassValue[]) { return twMerge(clsx(inputs)); }` which creates a utility function accepting unlimited className arguments including strings, arrays, objects, and conditional logic, combining them with clsx then resolving Tailwind conflicts with twMerge. Test the function in App.tsx by importing `import { cn } from './lib/utils'` and using it in className props: `<div className={cn('px-4 py-2', isActive && 'bg-green-500', 'px-6')}>Test</div>` which should apply px-6 (not px-4 due to twMerge conflict resolution), py-2, and bg-green-500 if isActive is true, demonstrating conditional classes and conflict resolution. Use this pattern consistently throughout all components instead of string concatenation: replace `className={"base-class " + (condition ? "conditional-class" : "")}` with `className={cn("base-class", condition && "conditional-class")}` for cleaner, more maintainable code, and leverage object syntax for multiple conditions: `cn("base", { "text-red-500": isError, "text-green-500": isSuccess })` applying red text if isError=true or green text if isSuccess=true. Create additional utility functions in the same file for common patterns: `export function formatCurrency(amount: number) { return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(amount); }` for consistent $XXX.XX formatting, `export function formatPhoneNumber(phone: string) { return phone.replace(/(\d{3})(\d{3})(\d{4})/, '($1) $2-$3'); }` for (XXX) XXX-XXXX format, and `export function truncate(str: string, length: number) { return str.length > length ? str.substring(0, length) + '...' : str; }` for ellipsis truncation, providing a centralized location for common formatting logic used across multiple components.

18. **Set up Tailwind config with custom colors: primary green (#10b981), secondary blue, and neutral grays**

Open `tailwind.config.js` and completely replace the theme.extend object with this exact color configuration: `theme: { extend: { colors: { primary: { 50: '#ecfdf5', 100: '#d1fae5', 200: '#a7f3d0', 300: '#6ee7b7', 400: '#34d399', 500: '#10b981', 600: '#059669', 700: '#047857', 800: '#065f46', 900: '#064e3b', 950: '#022c22' }, secondary: { 50: '#eff6ff', 100: '#dbeafe', 200: '#bfdbfe', 300: '#93c5fd', 400: '#60a5fa', 500: '#3b82f6', 600: '#2563eb', 700: '#1d4ed8', 800: '#1e40af', 900: '#1e3a8a', 950: '#172554' }, gray: { 50: '#f9fafb', 100: '#f3f4f6', 200: '#e5e7eb', 300: '#d1d5db', 400: '#9ca3af', 500: '#6b7280', 600: '#4b5563', 700: '#374151', 800: '#1f2937', 900: '#111827', 950: '#030712' } } } }` which defines complete color palettes with 11 shades (50-950) following Tailwind's standard scale, where primary-500 (#10b981) is the emerald green main brand color for buttons and accents, secondary-500 (#3b82f6) is blue for informational elements, and gray provides neutral UI backgrounds and text. Test colors by creating elements in App.tsx: `<div className="bg-primary-500 text-white p-4">Primary Button</div>`, `<div className="bg-secondary-100 text-secondary-700 p-4">Info Badge</div>`, and `<div className="bg-gray-100 text-gray-900 p-4">Neutral Card</div>` to verify the custom color classes work and display with correct hex values in browser DevTools (inspect element and check computed background-color should show rgb(16, 185, 129) for primary-500). Add semantic color mappings for job statuses in the same theme.extend.colors object: `'status-scheduled': '#60a5fa', 'status-in-progress': '#fbbf24', 'status-completed': '#10b981', 'status-cancelled': '#ef4444'` providing dedicated colors for blue scheduled, amber in-progress, green completed, and red cancelled states. Update the colors object to also include success/warning/error variants: `success: { light: '#d1fae5', DEFAULT: '#10b981', dark: '#047857' }, warning: { light: '#fef3c7', DEFAULT: '#f59e0b', dark: '#b45309' }, error: { light: '#fee2e2', DEFAULT: '#ef4444', dark: '#b91c1c' }` for consistent color usage in alerts, toasts, validation messages, and status indicators throughout the application, ensuring all color references use these semantic names (bg-success, text-error, border-warning) rather than arbitrary color values for better maintainability and theme consistency.

19. **Configure Tailwind to include safelist for dynamic classes used in job type color coding**

In `tailwind.config.js`, add a safelist array at the root level (same level as content and theme) with this exact configuration: `safelist: [ { pattern: /bg-(primary|secondary|blue|green|amber|red|purple|pink)-(100|200|500|600)/ }, { pattern: /text-(primary|secondary|blue|green|amber|red|purple|pink)-(600|700|800)/ }, { pattern: /border-(primary|secondary|blue|green|amber|red|purple|pink)-(300|400|500)/ }, 'bg-blue-100', 'bg-green-100', 'bg-amber-100', 'bg-red-100', 'bg-purple-100', 'text-blue-700', 'text-green-700', 'text-amber-700', 'text-red-700', 'text-purple-700' ]` which tells Tailwind to include these color classes in the final CSS even if they're generated dynamically at runtime (e.g., `bg-${jobType}-100` template literals) preventing classes from being purged during build optimization. Add job type to color mapping object in the same config or in a separate constants file: `const JOB_TYPE_COLORS = { mowing: 'green', trimming: 'blue', edging: 'purple', mulching: 'amber', tree_trimming: 'green', tree_removal: 'red', stump_grinding: 'amber', other: 'gray' }` defining which background/text color corresponds to each job_type enum value from database. Test the safelist works by creating a component in App.tsx that dynamically applies classes: `const jobType = 'mowing'; const colorClass = JOB_TYPE_COLORS[jobType]; return <div className={`bg-${colorClass}-100 text-${colorClass}-700 border-${colorClass}-300`}>Mowing Job</div>` which should render with green background (#d1fae5), dark green text (#047857), and light green border even though the className string is constructed dynamically at runtime. Add additional safelist patterns for responsive classes if using dynamic responsive utilities: `{ pattern: /(sm|md|lg):bg-(primary|blue|green)-(100|500)/ }` allowing classes like `md:bg-primary-500` to be generated dynamically, and include commonly toggled utility classes: `'hidden', 'block', 'flex', 'grid', 'opacity-0', 'opacity-100', 'scale-0', 'scale-100'` ensuring transition and animation classes remain available when applied conditionally with JavaScript state changes.

20. **Create src/components folder for all React components**

Create a new directory named `components` inside the `src` folder by running `mkdir src/components` in terminal or using your IDE's file explorer to create the folder structure, establishing the primary location for all React component files following standard React project architecture where components are separated from pages, hooks, utilities, and stores. Inside this components folder, immediately create a test component file `src/components/TestComponent.tsx` with this boilerplate: `interface TestComponentProps { message: string; } export function TestComponent({ message }: TestComponentProps) { return <div className="p-4 bg-gray-100 rounded-lg">{message}</div>; }` demonstrating proper TypeScript interface definition for props, named export (not default export for better refactoring and tree-shaking), and basic Tailwind styling. Import and render this test component in App.tsx with `import { TestComponent } from './components/TestComponent'; function App() { return <TestComponent message="Components folder working!" />; }` and verify it renders with gray background, 16px padding, and rounded corners, confirming the components folder is properly configured in the project structure. Establish naming conventions: use PascalCase for component files matching the component name exactly (Button.tsx exports Button component), place each major component in its own file (avoid multiple exports per file except for tightly coupled sub-components), and group related components in subdirectories (e.g., src/components/forms/LoginForm.tsx, src/components/cards/JobCard.tsx) as the component library grows beyond 10-15 components. Document the folder structure in a README.md inside components folder: `# Components Directory\n\nAll reusable React components live here.\n\n## Structure\n- /ui - Basic reusable UI components (Button, Input, Card)\n- /features - Feature-specific components (CustomerList, JobCalendar)\n- /layout - Layout components (Header, Sidebar, Footer)` providing clear guidance for where new components should be placed as the project scales to 50-100+ components.

21. **Create src/components/ui folder for reusable UI components**

Inside the existing `src/components` directory, create a new subdirectory named `ui` by running `mkdir src/components/ui` which will house all atomic, reusable UI components like buttons, inputs, modals, cards, and badges that are framework-agnostic and used across multiple features throughout the application. Create an index.ts barrel file at `src/components/ui/index.ts` with these exports: `export { Button } from './Button'; export { Input } from './Input'; export { Card } from './Card'; export { Modal } from './Modal';` (adding more as you create them) enabling cleaner imports in other files with `import { Button, Card } from '@/components/ui'` instead of individual file imports, improving code organization and reducing import statement clutter. Create a template component `src/components/ui/Button.tsx` demonstrating the UI component pattern: `import { ButtonHTMLAttributes, forwardRef } from 'react'; import { cn } from '@/lib/utils'; interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> { variant?: 'primary' | 'secondary' | 'ghost' | 'danger'; size?: 'sm' | 'md' | 'lg'; isLoading?: boolean; } export const Button = forwardRef<HTMLButtonElement, ButtonProps>(({ className, variant = 'primary', size = 'md', isLoading, children, disabled, ...props }, ref) => { return <button ref={ref} className={cn('rounded-lg font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed', { 'bg-primary-500 text-white hover:bg-primary-600 focus:ring-primary-500': variant === 'primary', 'px-3 py-1.5 text-sm': size === 'sm', 'px-4 py-2 text-base': size === 'md', 'px-6 py-3 text-lg': size === 'lg' }, className)} disabled={disabled || isLoading} {...props}>{isLoading ? 'Loading...' : children}</button>; });` which accepts all standard button attributes via spread props, uses forwardRef for ref forwarding to enable parent components to access the underlying DOM element, implements variant and size props for different button styles (primary green, secondary blue, ghost transparent, danger red with small/medium/large sizes), and handles loading state by showing "Loading..." text and disabling the button. Test this button component in App.tsx: `<div className="space-y-4 p-8"><Button>Primary</Button><Button variant="secondary" size="lg">Secondary Large</Button><Button variant="danger" size="sm" isLoading>Deleting...</Button></div>` verifying all variants render with correct colors (primary green #10b981, secondary blue #3b82f6, danger red #ef4444), sizes apply correct padding (sm: 12px/6px, md: 16px/8px, lg: 24px/12px), and loading state shows "Loading..." text with disabled cursor, establishing the foundation for all other UI components to follow this same pattern of TypeScript props, className merging with cn(), and comprehensive variant support.

22. **Create src/components/features folder for feature-specific components**

Inside `src/components`, create a `features` directory with `mkdir src/components/features` to house all components that are specific to business features (customers, jobs, invoices, scheduling) rather than generic UI primitives, organizing components by domain feature rather than by type (all customer-related components together, all job components together). Create subdirectories for each major feature: `mkdir src/components/features/customers src/components/features/scheduling src/components/features/jobs src/components/features/invoicing src/components/features/photos src/components/features/reports` establishing clear separation of concerns where customer management components live in /customers, calendar/job scheduling in /scheduling, field app job views in /jobs, invoice generation and payment in /invoicing, photo capture/gallery in /photos, and analytics/charts in /reports. Create a template feature component at `src/components/features/customers/CustomerCard.tsx` demonstrating the pattern: `import { Card } from '@/components/ui'; import { Phone, Mail, MapPin } from 'lucide-react'; interface Customer { id: string; first_name: string; last_name: string; phone: string; email?: string; billing_address?: string; } interface CustomerCardProps { customer: Customer; onEdit: (id: string) => void; } export function CustomerCard({ customer, onEdit }: CustomerCardProps) { return <Card className="p-4 hover:shadow-lg transition-shadow cursor-pointer" onClick={() => onEdit(customer.id)}><h3 className="text-lg font-semibold text-gray-900">{customer.first_name} {customer.last_name}</h3><div className="mt-2 space-y-1 text-sm text-gray-600"><div className="flex items-center gap-2"><Phone className="w-4 h-4" />{customer.phone}</div>{customer.email && <div className="flex items-center gap-2"><Mail className="w-4 h-4" />{customer.email}</div>}</div></Card>; }` which imports UI components from the ui folder, accepts strongly-typed customer data and event handler props, and composes UI primitives into a feature-specific presentation component. Create an index.ts barrel file at `src/components/features/customers/index.ts` exporting all customer components: `export { CustomerCard } from './CustomerCard'; export { CustomerList } from './CustomerList'; export { CustomerForm } from './CustomerForm';` enabling clean feature-level imports like `import { CustomerCard, CustomerList } from '@/components/features/customers'` throughout the application. Test the structure by creating a mock customer object in App.tsx and rendering CustomerCard: `const mockCustomer = { id: '1', first_name: 'John', last_name: 'Smith', phone: '(502) 555-1234', email: 'john@example.com' }; return <CustomerCard customer={mockCustomer} onEdit={(id) => console.log('Edit:', id)} />` which should render a card with customer name as heading, phone icon with number, email icon with address, hover shadow effect, and clicking anywhere on the card logs "Edit: 1" to console, confirming proper component organization, TypeScript typing, and event handling.

23. **Create src/pages folder for page-level components**

Create a `pages` directory inside `src` with `mkdir src/pages` which will contain all top-level route components (Dashboard, Customers, Schedule, FieldApp, Invoices, Reports, Settings) that get rendered when navigating to specific URLs, distinguishing page components from smaller reusable components and establishing clear separation between routing concerns and component composition. Create a template page component at `src/pages/Dashboard.tsx` following this pattern: `import { useAuth } from '@/hooks/useAuth'; import { Card } from '@/components/ui'; export function Dashboard() { const { user } = useAuth(); return <div className="min-h-screen bg-gray-50"><div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"><h1 className="text-3xl font-bold text-gray-900 mb-8">Dashboard</h1><div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">{/* Stats cards will go here */}</div></div></div>; }` which includes responsive max-width container (1280px on large screens), responsive padding (16px mobile, 24px tablet, 32px desktop), full viewport height background, and responsive grid (1 column mobile, 2 columns tablet, 4 columns desktop) with 24px gaps between cards. Create pages for all major routes: `src/pages/Login.tsx` for authentication with no layout wrapper, `src/pages/Customers.tsx` for customer list view, `src/pages/CustomerDetail.tsx` with dynamic route parameter, `src/pages/Schedule.tsx` for calendar view, `src/pages/FieldApp.tsx` mobile-optimized for crew members, `src/pages/Invoices.tsx` for invoice list, `src/pages/Reports.tsx` for analytics, and `src/pages/Settings.tsx` for configuration. Update App.tsx routing to use these pages: `import { BrowserRouter, Routes, Route } from 'react-router-dom'; import { Dashboard } from './pages/Dashboard'; function App() { return <BrowserRouter><Routes><Route path="/" element={<Dashboard />} /><Route path="/login" element={<Login />} /></Routes></BrowserRouter>; }` replacing placeholder divs with actual page components and verifying navigation works by visiting http://localhost:5173/ showing the Dashboard page with heading and grid layout. Establish page component conventions: always export named function (not default export), include responsive layout wrappers (max-w-7xl, px-4, py-8), use semantic HTML (main, section, article, aside) for accessibility, implement page-level loading states with `if (isLoading) return <PageSkeleton />`, handle page-level errors with error boundaries, and add page titles with `useEffect(() => { document.title = 'Dashboard - Aaron\'s Lawn Care'; }, [])` for better browser tab identification and SEO.

24. **Create src/hooks folder for custom React hooks**

Create a `hooks` directory inside `src` with `mkdir src/hooks` dedicated to custom React hooks that encapsulate reusable stateful logic like authentication state, data fetching with React Query, form handling, geolocation access, and offline detection, following React's convention of prefixing all hook names with "use" (e.g., useAuth, useCustomers, useGeolocation). Create a template custom hook at `src/hooks/useAuth.ts` demonstrating proper hook patterns: `import { useAuthStore } from '@/stores/authStore'; import { supabase } from '@/lib/supabase'; export function useAuth() { const { user, setUser, setSession, loading, setLoading } = useAuthStore(); const signIn = async (email: string, password: string) => { try { setLoading(true); const { data, error } = await supabase.auth.signInWithPassword({ email, password }); if (error) throw error; setUser(data.user); setSession(data.session); return { success: true }; } catch (error) { return { success: false, error: error.message }; } finally { setLoading(false); } }; const signOut = async () => { await supabase.auth.signOut(); setUser(null); setSession(null); }; return { user, loading, signIn, signOut, isAuthenticated: !!user }; }` which wraps Zustand store access, provides async authentication functions with proper error handling and loading states, and returns a clean API with derived state (isAuthenticated computed from user). Create additional hooks following the same pattern: `src/hooks/useCustomers.ts` using TanStack Query for data fetching `export function useCustomers() { return useQuery({ queryKey: ['customers'], queryFn: async () => { const { data, error } = await supabase.from('customers').select('*'); if (error) throw error; return data; } }); }`, `src/hooks/useMediaQuery.ts` for responsive breakpoint detection `export function useMediaQuery(query: string) { const [matches, setMatches] = useState(false); useEffect(() => { const media = window.matchMedia(query); setMatches(media.matches); const listener = () => setMatches(media.matches); media.addEventListener('change', listener); return () => media.removeEventListener('change', listener); }, [query]); return matches; }`, and `src/hooks/useDebounce.ts` for debouncing rapid input changes `export function useDebounce<T>(value: T, delay: number = 500) { const [debouncedValue, setDebouncedValue] = useState(value); useEffect(() => { const handler = setTimeout(() => setDebouncedValue(value), delay); return () => clearTimeout(handler); }, [value, delay]); return debouncedValue; }`. Create barrel export file `src/hooks/index.ts` with `export { useAuth } from './useAuth'; export { useCustomers } from './useCustomers'; export { useMediaQuery } from './useMediaQuery'; export { useDebounce } from './useDebounce';` enabling clean imports like `import { useAuth, useMediaQuery } from '@/hooks'` throughout the application. Test hooks by using them in App.tsx: `const { user, isAuthenticated } = useAuth(); const isMobile = useMediaQuery('(max-width: 768px)'); return <div>{isAuthenticated ? `Welcome ${user?.email}` : 'Not logged in'}<br />{isMobile ? 'Mobile view' : 'Desktop view'}</div>` which should display authentication status and screen size detection, confirming hooks work correctly and follow React's rules of hooks (only call at top level, only call from React functions).

25. **Create src/stores folder for Zustand state stores**

Create a `stores` directory inside `src` with `mkdir src/stores` to house all Zustand state management stores for client-side state (auth, UI state, offline queue) separate from server state managed by React Query, organizing global state by domain (authStore, uiStore, offlineStore) rather than in a single monolithic store. Create `src/stores/authStore.ts` as the primary authentication store: `import { create } from 'zustand'; import { persist } from 'zustand/middleware'; interface User { id: string; email: string; full_name: string; role: 'owner' | 'admin' | 'crew_lead' | 'crew_member'; } interface AuthState { user: User | null; session: any | null; loading: boolean; setUser: (user: User | null) => void; setSession: (session: any | null) => void; setLoading: (loading: boolean) => void; reset: () => void; } export const useAuthStore = create<AuthState>()(persist((set) => ({ user: null, session: null, loading: true, setUser: (user) => set({ user }), setSession: (session) => set({ session }), setLoading: (loading) => set({ loading }), reset: () => set({ user: null, session: null, loading: false }) }), { name: 'auth-storage', partialize: (state) => ({ user: state.user, session: state.session }) }))` which uses persist middleware to automatically sync auth state to localStorage, partialize option to only persist user and session (not loading), and provides type-safe actions for updating state. Create `src/stores/uiStore.ts` for UI state like modals, sidebars, and sheets: `import { create } from 'zustand'; interface UIState { sidebarOpen: boolean; currentModal: string | null; currentSheet: string | null; setSidebarOpen: (open: boolean) => void; openModal: (modal: string) => void; closeModal: () => void; openSheet: (sheet: string) => void; closeSheet: () => void; } export const useUIStore = create<UIState>((set) => ({ sidebarOpen: true, currentModal: null, currentSheet: null, setSidebarOpen: (open) => set({ sidebarOpen: open }), openModal: (modal) => set({ currentModal: modal }), closeModal: () => set({ currentModal: null }), openSheet: (sheet) => set({ currentSheet: sheet }), closeSheet: () => set({ currentSheet: null }) }))` providing centralized control over UI elements that need to be accessed from multiple components (e.g., opening a modal from anywhere). Create `src/stores/offlineStore.ts` for offline queue management: `import { create } from 'zustand'; interface OfflineAction { id: string; type: string; payload: any; timestamp: number; } interface OfflineState { queue: OfflineAction[]; isOnline: boolean; addToQueue: (action: Omit<OfflineAction, 'id' | 'timestamp'>) => void; removeFromQueue: (id: string) => void; clearQueue: () => void; setOnline: (online: boolean) => void; } export const useOfflineStore = create<OfflineState>((set) => ({ queue: [], isOnline: navigator.onLine, addToQueue: (action) => set((state) => ({ queue: [...state.queue, { ...action, id: crypto.randomUUID(), timestamp: Date.now() }] })), removeFromQueue: (id) => set((state) => ({ queue: state.queue.filter(a => a.id !== id) })), clearQueue: () => set({ queue: [] }), setOnline: (online) => set({ isOnline: online }) }))` tracking offline actions and online status for PWA functionality. Test stores by importing them in App.tsx: `const { user, setUser } = useAuthStore(); const { sidebarOpen, setSidebarOpen } = useUIStore(); return <div><button onClick={() => setUser({ id: '1', email: 'test@test.com', full_name: 'Test User', role: 'owner' })}>Set User</button><button onClick={() => setSidebarOpen(!sidebarOpen)}>Toggle Sidebar</button><pre>{JSON.stringify({ user, sidebarOpen }, null, 2)}</pre></div>` which should allow setting user data, toggling sidebar state, and display current state in JSON format, confirming stores work correctly and persist to localStorage (refresh page and user should remain logged in).

26. **Create src/services folder for API service functions**

Create a `services` directory inside `src` with `mkdir src/services` to house all API interaction functions that communicate with Supabase backend, organizing data access logic separate from React components and hooks following the repository pattern for better testability and maintainability. Create `src/services/customerService.ts` with CRUD operations: `import { supabase } from '@/lib/supabase'; import { Database } from '@/lib/database.types'; type Customer = Database['public']['Tables']['customers']['Row']; type CustomerInsert = Database['public']['Tables']['customers']['Insert']; type CustomerUpdate = Database['public']['Tables']['customers']['Update']; export async function getCustomers() { const { data, error } = await supabase.from('customers').select('*').order('created_at', { ascending: false }); if (error) throw error; return data; } export async function getCustomer(id: string) { const { data, error } = await supabase.from('customers').select('*, properties(*)').eq('id', id).single(); if (error) throw error; return data; } export async function createCustomer(customer: CustomerInsert) { const { data, error } = await supabase.from('customers').insert(customer).select().single(); if (error) throw error; return data; } export async function updateCustomer(id: string, updates: CustomerUpdate) { const { data, error } = await supabase.from('customers').update(updates).eq('id', id).select().single(); if (error) throw error; return data; } export async function deleteCustomer(id: string) { const { error } = await supabase.from('customers').delete().eq('id', id); if (error) throw error; }` which uses generated TypeScript types from database schema, throws errors for React Query error boundaries to catch, returns typed data for autocomplete in components, and includes related data fetching with properties join in getCustomer. Create similar service files: `src/services/jobService.ts` with job CRUD plus status updates `export async function updateJobStatus(jobId: string, status: string) { const { data, error } = await supabase.from('jobs').update({ status, actual_start_time: status === 'in_progress' ? new Date().toISOString() : undefined, actual_end_time: status === 'completed' ? new Date().toISOString() : undefined }).eq('id', jobId).select().single(); if (error) throw error; return data; }`, `src/services/invoiceService.ts` with invoice generation `export async function createInvoiceFromJob(jobId: string) { const { data: job, error: jobError } = await supabase.from('jobs').select('*, customer:customers(*)').eq('id', jobId).single(); if (jobError) throw jobError; const invoice = { user_id: job.user_id, customer_id: job.customer_id, job_id: jobId, subtotal: 50.00, tax_rate: 0.06, tax_amount: 3.00, total_amount: 53.00, issue_date: new Date().toISOString().split('T')[0], due_date: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0] }; return createInvoice(invoice); }`, and `src/services/photoService.ts` with upload handling `export async function uploadJobPhoto(jobId: string, file: File, photoType: 'before' | 'during' | 'after') { const filename = `${jobId}/${Date.now()}-${crypto.randomUUID()}.${file.name.split('.').pop()}`; const { data: uploadData, error: uploadError } = await supabase.storage.from('job-photos').upload(filename, file); if (uploadError) throw uploadError; const { data, error } = await supabase.from('job_photos').insert({ job_id: jobId, storage_path: uploadData.path, photo_type: photoType, file_size: file.size }).select().single(); if (error) throw error; return data; }`. Create barrel export `src/services/index.ts`: `export * from './customerService'; export * from './jobService'; export * from './invoiceService'; export * from './photoService';` enabling imports like `import { getCustomers, createCustomer } from '@/services'`. Test services by calling them from App.tsx in a useEffect: `useEffect(() => { getCustomers().then(customers => console.log('Customers:', customers)).catch(error => console.error('Error:', error)); }, [])` which should log customer data from database or error message, confirming service layer works and errors properly propagate.

27. **Create src/styles folder with globals.css importing Tailwind directives**

Create a `styles` directory inside `src` with `mkdir src/styles` to house global CSS files including Tailwind imports, custom CSS utilities, and third-party library style overrides, centralizing all styling configuration separate from component files. Create `src/styles/globals.css` (rename from index.css if it exists) with this exact content: `@tailwind base; @tailwind components; @tailwind utilities; @layer base { * { @apply border-border; } body { @apply bg-background text-foreground; font-feature-settings: "rlig" 1, "calt" 1; } } @layer components { .btn { @apply px-4 py-2 rounded-lg font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2; } .card { @apply bg-white rounded-lg shadow-sm border border-gray-200 p-4; } .input { @apply w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent; } } @layer utilities { .scrollbar-hide::-webkit-scrollbar { display: none; } .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; } }` which imports Tailwind's base styles, component utilities, and custom utilities, defines base element styling in @layer base for consistent defaults (all borders use CSS variable colors, body gets background/foreground colors, enables font ligatures), creates reusable component classes in @layer components like .btn, .card, .input for common patterns without cluttering Tailwind classes, and adds utility classes in @layer utilities like .scrollbar-hide for hiding scrollbars in overflow containers. Add custom CSS variables at the top of the file before @tailwind directives: `@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap'); :root { --background: 0 0% 100%; --foreground: 222.2 47.4% 11.2%; --border: 214.3 31.8% 91.4%; --ring: 142.1 76.2% 36.3%; --radius: 0.5rem; } * { margin: 0; padding: 0; box-sizing: border-box; } body { font-family: 'Inter', system-ui, -apple-system, sans-serif; line-height: 1.5; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }` importing Inter font from Google Fonts for consistent typography, defining CSS custom properties for colors using HSL values enabling theme switching, resetting default margins/paddings, setting box-sizing border-box globally, and applying Inter font with system font fallbacks plus font smoothing for better rendering on Mac/Windows. Update `src/main.tsx` to import this global stylesheet: `import './styles/globals.css'` (change from './index.css' if needed) ensuring Tailwind directives and custom styles load before React renders, and delete old index.css file if it exists. Test custom classes work by adding them to App.tsx: `<button className="btn bg-primary-500 text-white">Button</button><div className="card">Card Content</div><input type="text" className="input" placeholder="Test input" />` which should render button with .btn base styles plus color overrides, card with white background, shadow, border, and padding, and input with border, focus ring, and full width, confirming global styles apply correctly and Tailwind utilities still work for overriding component class defaults.

28. **Install vite-plugin-pwa for Progressive Web App functionality**

Run `npm install -D vite-plugin-pwa@0.17.4 workbox-window@7.0.0` to install the Vite PWA plugin which automatically generates service worker, web manifest, and handles caching strategies using Workbox under the hood, plus workbox-window for client-side service worker registration and updates. Import the plugin in `vite.config.ts` by adding `import { VitePWA } from 'vite-plugin-pwa'` at the top, then add it to the plugins array: `export default defineConfig({ plugins: [ react(), VitePWA({ registerType: 'autoUpdate', includeAssets: ['favicon.ico', 'robots.txt', 'icons/*.png'], manifest: { name: 'Aaron\'s Lawn Care Service', short_name: 'Aaron\'s Care', description: 'Business management for lawn care and tree removal', theme_color: '#10b981', background_color: '#ffffff', display: 'standalone', orientation: 'portrait', icons: [ { src: '/icons/icon-192.png', sizes: '192x192', type: 'image/png' }, { src: '/icons/icon-512.png', sizes: '512x512', type: 'image/png' }, { src: '/icons/icon-512.png', sizes: '512x512', type: 'image/png', purpose: 'any maskable' } ] }, workbox: { globPatterns: ['**/*.{js,css,html,ico,png,svg,woff2}'], runtimeCaching: [ { urlPattern: /^https:\/\/.*\.supabase\.co\/rest\/v1\/.*/i, handler: 'NetworkFirst', options: { cacheName: 'supabase-api', expiration: { maxEntries: 50, maxAgeSeconds: 5 * 60 }, networkTimeoutSeconds: 10 } }, { urlPattern: /^https:\/\/.*\.supabase\.co\/storage\/v1\/.*/i, handler: 'CacheFirst', options: { cacheName: 'supabase-storage', expiration: { maxEntries: 100, maxAgeSeconds: 30 * 24 * 60 * 60 } } } ] }, devOptions: { enabled: true, type: 'module' } }) ] })` configuring automatic service worker updates, precaching all static assets (JS/CSS/HTML/images/fonts), defining app manifest with name/icons/colors for Add to Home Screen, setting up Workbox runtime caching with NetworkFirst strategy for API calls (network preferred, cache fallback with 10-second timeout) and CacheFirst for storage/photos (cache preferred, 30-day expiration), and enabling PWA in development mode for testing. Create a service worker registration file `src/registerSW.ts`: `import { registerSW } from 'virtual:pwa-register'; const updateSW = registerSW({ onNeedRefresh() { if (confirm('New version available! Reload to update?')) { updateSW(true); } }, onOfflineReady() { console.log('App ready to work offline'); } });` handling service worker lifecycle events with user-friendly update prompts and offline-ready confirmation. Import this in `src/main.tsx` after React render: `import './registerSW'` ensuring service worker registers after initial app load, and test PWA functionality by running `npm run build && npm run preview`, opening http://localhost:4173 in Chrome, opening DevTools → Application tab → Service Workers panel to verify service worker is registered and running, checking Manifest tab shows app name and icons correctly, and using Lighthouse audit (DevTools → Lighthouse → Progressive Web App) which should score 90+ indicating installable PWA with offline capabilities.

29. **Configure vite.config.js with PWA plugin including manifest and service worker settings**

Open `vite.config.ts` and update the VitePWA plugin configuration with comprehensive settings for production-ready PWA: `VitePWA({ registerType: 'prompt', injectRegister: 'auto', includeAssets: ['favicon.ico', 'robots.txt', 'apple-touch-icon.png'], manifest: { name: 'Aaron\'s Lawn Care Service', short_name: 'Aaron\'s Care', description: 'Professional lawn care and tree removal business management platform', theme_color: '#10b981', background_color: '#ffffff', display: 'standalone', orientation: 'portrait-primary', scope: '/', start_url: '/', icons: [ { src: '/icons/icon-72.png', sizes: '72x72', type: 'image/png' }, { src: '/icons/icon-96.png', sizes: '96x96', type: 'image/png' }, { src: '/icons/icon-128.png', sizes: '128x128', type: 'image/png' }, { src: '/icons/icon-144.png', sizes: '144x144', type: 'image/png' }, { src: '/icons/icon-152.png', sizes: '152x152', type: 'image/png' }, { src: '/icons/icon-192.png', sizes: '192x192', type: 'image/png' }, { src: '/icons/icon-384.png', sizes: '384x384', type: 'image/png' }, { src: '/icons/icon-512.png', sizes: '512x512', type: 'image/png' }, { src: '/icons/icon-512.png', sizes: '512x512', type: 'image/png', purpose: 'any maskable' } ], categories: ['business', 'productivity'], screenshots: [ { src: '/screenshots/desktop-1.png', sizes: '1280x720', type: 'image/png', form_factor: 'wide' }, { src: '/screenshots/mobile-1.png', sizes: '750x1334', type: 'image/png', form_factor: 'narrow' } ] }, workbox: { globPatterns: ['**/*.{js,css,html,ico,png,svg,woff2,woff,ttf,eot}'], globIgnores: ['**/node_modules/**/*', 'sw.js', 'workbox-*.js'], maximumFileSizeToCacheInBytes: 3 * 1024 * 1024, cleanupOutdatedCaches: true, runtimeCaching: [ { urlPattern: /^https:\/\/.*\.supabase\.co\/rest\/v1\/.*/i, handler: 'NetworkFirst', options: { cacheName: 'supabase-api-cache', expiration: { maxEntries: 50, maxAgeSeconds: 5 * 60 }, cacheableResponse: { statuses: [0, 200] }, networkTimeoutSeconds: 10 } }, { urlPattern: /^https:\/\/.*\.supabase\.co\/storage\/v1\/object\/public\/.*/i, handler: 'CacheFirst', options: { cacheName: 'supabase-storage-cache', expiration: { maxEntries: 100, maxAgeSeconds: 30 * 24 * 60 * 60 }, cacheableResponse: { statuses: [0, 200] } } }, { urlPattern: /^https:\/\/fonts\.googleapis\.com\/.*/i, handler: 'StaleWhileRevalidate', options: { cacheName: 'google-fonts-stylesheets' } }, { urlPattern: /^https:\/\/fonts\.gstatic\.com\/.*/i, handler: 'CacheFirst', options: { cacheName: 'google-fonts-webfonts', expiration: { maxEntries: 30, maxAgeSeconds: 365 * 24 * 60 * 60 }, cacheableResponse: { statuses: [0, 200] } } } ], navigateFallback: '/index.html', navigateFallbackDenylist: [/^\/api\//] }, devOptions: { enabled: true, type: 'module', navigateFallback: 'index.html' } })` which sets registerType to 'prompt' requiring user confirmation before updating (better UX than autoUpdate), includes all asset types including fonts (woff2/woff/ttf/eot), sets 3MB maximum file size for precaching preventing memory issues, enables cleanupOutdatedCaches to remove old service worker caches automatically, configures NetworkFirst for API with 10-second timeout and 5-minute cache falling back to cache if network fails, CacheFirst for photos/storage with 30-day expiration, StaleWhileRevalidate for Google Fonts stylesheets serving cached version while fetching update in background, CacheFirst for Google Fonts webfonts with 1-year expiration since fonts rarely change, navigateFallback to index.html for SPA routing ensuring all non-API routes return the app shell, and navigateFallbackDenylist excluding /api/ routes from SPA fallback. Add TypeScript types at the top of vite.config.ts: `/// <reference types="vite-plugin-pwa/client" />` enabling autocomplete for PWA types, and add injectManifest option if you want custom service worker: `strategies: 'injectManifest', srcDir: 'src', filename: 'sw.ts'` allowing full control over service worker logic for advanced offline scenarios like background sync and push notifications, though generateSW (default) is sufficient for MVP needs. Test the configuration by building with `npm run build` and checking dist/manifest.webmanifest file exists with all icons and metadata, dist/sw.js service worker exists with Workbox runtime code, and running `npm run preview` then testing offline mode by opening Chrome DevTools → Network tab → throttle to "Offline" → refresh page which should still load from service worker cache showing offline capability working correctly.

30. **Create public/manifest.json with app name, colors, and icon paths**

Create a `public` directory in project root with `mkdir public` if it doesn't exist (Vite scaffold usually creates this), then create `public/manifest.json` (note: this will be replaced by auto-generated manifest.webmanifest from vite-plugin-pwa, but creating manually first helps understand the structure) with this exact JSON: `{ "name": "Aaron's Lawn Care Service", "short_name": "Aaron's Care", "description": "Professional business management platform for lawn care and tree removal services", "start_url": "/", "scope": "/", "display": "standalone", "orientation": "portrait-primary", "theme_color": "#10b981", "background_color": "#ffffff", "categories": ["business", "productivity", "utilities"], "icons": [ { "src": "/icons/icon-72.png", "sizes": "72x72", "type": "image/png", "purpose": "any" }, { "src": "/icons/icon-96.png", "sizes": "96x96", "type": "image/png", "purpose": "any" }, { "src": "/icons/icon-128.png", "sizes": "128x128", "type": "image/png", "purpose": "any" }, { "src": "/icons/icon-144.png", "sizes": "144x144", "type": "image/png", "purpose": "any" }, { "src": "/icons/icon-152.png", "sizes": "152x152", "type": "image/png", "purpose": "any" }, { "src": "/icons/icon-192.png", "sizes": "192x192", "type": "image/png", "purpose": "any" }, { "src": "/icons/icon-384.png", "sizes": "384x384", "type": "image/png", "purpose": "any" }, { "src": "/icons/icon-512.png", "sizes": "512x512", "type": "image/png", "purpose": "any" }, { "src": "/icons/icon-512.png", "sizes": "512x512", "type": "image/png", "purpose": "maskable" } ], "screenshots": [ { "src": "/screenshots/desktop-dashboard.png", "sizes": "1280x720", "type": "image/png", "form_factor": "wide", "label": "Dashboard view showing today's jobs and stats" }, { "src": "/screenshots/mobile-field-app.png", "sizes": "750x1334", "type": "image/png", "form_factor": "narrow", "label": "Mobile field app for crew members" } ], "shortcuts": [ { "name": "Today's Jobs", "short_name": "Jobs", "description": "View today's scheduled jobs", "url": "/field-app", "icons": [{ "src": "/icons/shortcut-jobs.png", "sizes": "192x192" }] }, { "name": "Create Invoice", "short_name": "Invoice", "description": "Create a new invoice", "url": "/invoices/new", "icons": [{ "src": "/icons/shortcut-invoice.png", "sizes": "192x192" }] } ] }` which defines app name appearing during installation (max 45 chars), short name for home screen icon (max 12 chars), display "standalone" removing browser UI for native app feel, portrait-primary orientation locking to vertical on mobile, theme_color #10b981 (primary green) coloring browser toolbar and status bar, background_color white shown during app launch before styles load, multiple icon sizes (72/96/128/144/152/192/384/512px) supporting all Android/iOS devices, purpose "maskable" icon for adaptive icons on Android with safe zone padding, screenshots for enhanced install dialog on supporting browsers (Chrome Android 90+, desktop none yet), and shortcuts for app launcher long-press actions enabling direct navigation to key features. Create the `public/icons` directory with `mkdir public/icons` and generate icon assets: use an online tool like https://realfavicongenerator.net or https://favicon.io with your lawn care logo (green circle with lawn mower or tree icon), upload source image (minimum 512x512px PNG with transparent background), generate all required sizes (72/96/128/144/152/192/384/512), download the zip file, and extract all icons to public/icons directory ensuring filenames match manifest exactly (icon-72.png, icon-96.png, etc.). For the maskable icon at 512x512, ensure your logo sits in the safe zone (80% of canvas centered) with extra padding around edges since Android will clip edges when applying adaptive icon mask, and test maskable icon with https://maskable.app by uploading icon-512.png and verifying logo remains visible with all mask shapes (circle, squircle, rounded square). Create `public/favicon.ico` by converting icon-192.png to ICO format using https://www.icoconverter.com for browser tab icon, and add `public/apple-touch-icon.png` (192x192 minimum) for iOS home screen icon which doesn't use manifest.json but requires this specific filename. Link the manifest in `index.html` by adding `<link rel="manifest" href="/manifest.json">` in the <head> section, add theme color meta tag `<meta name="theme-color" content="#10b981">`, and add Apple-specific meta tags: `<meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><link rel="apple-touch-icon" href="/apple-touch-icon.png">` for iOS PWA support. Test manifest works by running `npm run dev`, opening http://localhost:5173 in Chrome, opening DevTools → Application tab → Manifest section, verifying all fields show correctly with green checkmarks, icons display at all sizes, and clicking "Add to Home Screen" button in Application tab (or three-dot menu → Install app) successfully installs the PWA with correct icon, name, and theme color appearing on Android home screen or Chrome desktop as standalone app window without browser chrome.
# Dyad Project: Expanded Development Prompts (31-60)

## PROMPTS 31-50: Project Infrastructure & Tooling

31. Create a `public/icons` directory structure and generate two PNG icon files: `icon-192x192.png` and `icon-512x512.png` with exact dimensions of 192×192 pixels and 512×512 pixels respectively, featuring a modern lawn care logo with green (#22c55e) and earth brown (#92400e) color scheme on transparent background. Use a design tool like Figma or Canva to create a minimalist icon showing a stylized grass blade or lawn mower silhouette with rounded corners (8px border-radius equivalent). Optimize both PNG files to under 50KB each using tools like TinyPNG, and ensure they follow PWA manifest icon requirements with proper contrast ratios (4.5:1 minimum). Add these files to the PWA manifest.json with purpose "any maskable" and corresponding sizes array entries.

32. Install and configure ESLint with React, TypeScript, and accessibility rules by running `npm install -D eslint @typescript-eslint/eslint-plugin @typescript-eslint/parser eslint-plugin-react eslint-plugin-react-hooks eslint-plugin-jsx-a11y eslint-plugin-import`. Create `.eslintrc.json` with extends array including `["@typescript-eslint/recommended", "plugin:react/recommended", "plugin:react-hooks/recommended", "plugin:jsx-a11y/recommended"]` and parser set to `@typescript-eslint/parser`. Configure parserOptions with `ecmaVersion: 2022`, `sourceType: "module"`, and `ecmaFeatures: { jsx: true }`. Add specific rules: `"react/react-in-jsx-scope": "off"`, `"@typescript-eslint/no-unused-vars": "error"`, `"jsx-a11y/anchor-is-valid": "warn"`, and `"import/order": ["error", { "groups": ["builtin", "external", "internal"] }]`. Set environment to include `browser: true`, `es2022: true`, and `node: true`.

33. Install Prettier with `npm install -D prettier` and create `.prettierrc.json` with exact configuration: `{ "semi": true, "trailingComma": "es5", "singleQuote": true, "printWidth": 80, "tabWidth": 2, "useTabs": false }`. Create `.prettierignore` file including `dist/`, `build/`, `node_modules/`, `*.md`, and `public/`. Add VS Code settings in `.vscode/settings.json` with `"editor.formatOnSave": true`, `"editor.defaultFormatter": "esbenp.prettier-vscode"`, and `"editor.codeActionsOnSave": { "source.fixAll.eslint": true }`. Configure package.json script: `"format": "prettier --write \"src/**/*.{js,jsx,ts,tsx,json,css,scss,md}\""` and `"format:check": "prettier --check \"src/**/*.{js,jsx,ts,tsx,json,css,scss,md}\""`.

34. Create comprehensive `.gitignore` file with exact entries: `node_modules/`, `.env`, `.env.local`, `.env.development.local`, `.env.test.local`, `.env.production.local`, `dist/`, `build/`, `.vite/`, `*.log`, `npm-debug.log*`, `yarn-debug.log*`, `yarn-error.log*`, `.DS_Store`, `Thumbs.db`, `.vscode/`, `.idea/`, `coverage/`, `.nyc_output/`, `.temp/`, `.cache/`, and `*.tsbuildinfo`. Organize sections with comments like `# Dependencies`, `# Environment variables`, `# Build outputs`, `# Logs`, `# OS generated files`, `# IDE files`, `# Testing`, and `# Temporary files`. Ensure each line ends with `/` for directories and includes common Vite, React, and TypeScript artifacts. Add `.gitattributes` with `* text=auto` and `*.png binary` for proper line ending handling.

35. Initialize Git repository with `git init`, configure user with `git config user.name "Developer Name"` and `git config user.email "developer@email.com"`, then stage all files with `git add .` and create initial commit with message `git commit -m "feat: initial project setup with Vite, React, TypeScript, and Tailwind"`. Set up default branch as main with `git branch -M main` and configure Git to use main as default for new repositories. Verify commit integrity with `git log --oneline` and ensure all project files are properly tracked except those in .gitignore. Use conventional commit format for all future commits with prefixes: feat, fix, docs, style, refactor, perf, test, chore.

36. Create GitHub repository named "dyad-lawn-care" with description "Modern lawn care business management platform built with React, TypeScript, and Supabase" and set visibility to private. Add remote origin with `git remote add origin https://github.com/username/dyad-lawn-care.git` and push initial code with `git push -u origin main`. Configure repository settings: enable branch protection for main branch requiring PR reviews, enable automatic security updates, add topics: `react`, `typescript`, `supabase`, `tailwindcss`, `lawn-care`, `business-management`. Set up GitHub Actions workflow permissions to read and write, configure default reviewer as repository owner, and enable vulnerability alerts. Create repository secrets for SUPABASE_URL and SUPABASE_ANON_KEY for CI/CD pipeline.

37. Install Stripe payment processing with `npm install @stripe/stripe-js @stripe/react-stripe-js` and create `src/lib/stripe.ts` with `loadStripe()` function using publishable key from environment variable `VITE_STRIPE_PUBLISHABLE_KEY`. Initialize Stripe instance with configuration: `{ apiVersion: '2023-10-16', typescript: true }` and implement error boundary wrapper for Stripe elements. Create type definitions for payment intents, customer objects, and subscription status in `src/types/stripe.ts`. Implement retry logic for failed Stripe API calls with exponential backoff (1s, 2s, 4s delays) and maximum 3 retries. Add Stripe Elements provider at app root level with appearance theme matching Tailwind design tokens and custom CSS variables for form styling.

38. Install Google Maps integration with `npm install @googlemaps/js-api-loader @types/google.maps` and create `src/lib/googleMaps.ts` with Loader configuration using API key from `VITE_GOOGLE_MAPS_API_KEY`. Set libraries array to `["places", "geometry", "drawing"]` and version to "weekly" for latest features. Implement lazy loading wrapper component `MapLoader` that only loads Google Maps API when map component is mounted, with loading state and error handling. Create TypeScript interfaces for place predictions, geocoding results, and distance matrix responses. Add retry mechanism for API failures with 5-second timeout and fallback to show offline message if maps fail to load after 3 attempts.

39. Create comprehensive package.json scripts object with: `"dev": "vite --port 3000 --host"`, `"build": "tsc && vite build"`, `"preview": "vite preview --port 3001"`, `"lint": "eslint src --ext .ts,.tsx --report-unused-disable-directives --max-warnings 0"`, `"lint:fix": "eslint src --ext .ts,.tsx --fix"`, `"type-check": "tsc --noEmit"`, and `"clean": "rm -rf dist build node_modules/.vite"`. Add pre-commit script `"pre-commit": "npm run type-check && npm run lint && npm run format:check"` to ensure code quality. Configure concurrent development with `"dev:full": "concurrently \"npm run dev\" \"npm run type-check -- --watch\""` to run Vite dev server and TypeScript compiler in watch mode. Include build analysis script `"analyze": "vite build --mode analyze"` for bundle size monitoring.

40. Configure absolute imports by modifying `vite.config.ts` to include `resolve: { alias: { '@': path.resolve(__dirname, './src') } }` and update `tsconfig.json` compilerOptions with `"baseUrl": "."` and `"paths": { "@/*": ["src/*"] }`. Import path module at top of vite.config.ts with `import path from 'node:path'`. Create barrel exports in `src/index.ts` for commonly used modules like components, hooks, utils, and types. Update all import statements throughout codebase to use `@/` prefix instead of relative paths, starting with most deeply nested components first. Verify path resolution works in VS Code intellisense and ensure build process correctly resolves aliases without errors.

41. Create comprehensive `README.md` with project title, description, tech stack section listing React 18, TypeScript 5, Vite 5, Tailwind CSS 3, Supabase, and Stripe integration. Include detailed setup instructions: clone repository, run `npm install`, copy `.env.example` to `.env`, fill in environment variables, run `npm run dev`. Document all required environment variables: `VITE_SUPABASE_URL`, `VITE_SUPABASE_ANON_KEY`, `VITE_STRIPE_PUBLISHABLE_KEY`, `VITE_GOOGLE_MAPS_API_KEY` with descriptions of where to obtain each key. Add development workflow section covering linting, formatting, testing, and commit conventions. Include deployment instructions for Vercel/Netlify with build command `npm run build` and output directory `dist`.

42. Install testing dependencies with `npm install -D vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom` and create `src/setupTests.ts` importing `@testing-library/jest-dom/extend-expect`. Configure package.json test scripts: `"test": "vitest"`, `"test:ui": "vitest --ui"`, `"test:run": "vitest run"`, and `"test:coverage": "vitest run --coverage"`. Create first test file `src/App.test.tsx` with basic render test using `render()` from testing library and `screen.getByText()` assertions. Set up test utilities in `src/test-utils.tsx` with custom render function that includes React Query and Router providers. Add Istanbul coverage configuration to track minimum 80% code coverage threshold.

43. Install Playwright with `npm install -D @playwright/test` and run `npx playwright install` to download browser binaries for Chromium, Firefox, and WebKit. Create `tests/` directory structure with `tests/auth.spec.ts`, `tests/dashboard.spec.ts`, and `tests/customer-management.spec.ts` for core user flows. Configure test scripts in package.json: `"test:e2e": "playwright test"`, `"test:e2e:headed": "playwright test --headed"`, `"test:e2e:debug": "playwright test --debug"`. Create page object model classes in `tests/pages/` for login, dashboard, and customer management pages with typed selectors and action methods. Set up GitHub Actions workflow to run Playwright tests on every PR with browser screenshots on failure.

44. Create `vitest.config.ts` extending from main Vite config with test-specific settings: `environment: 'jsdom'`, `setupFiles: ['src/setupTests.ts']`, `globals: true` for global test functions. Configure coverage provider as `c8` with coverage directory `coverage/` and include/exclude patterns for src files only. Set test timeout to 10000ms and add CSS modules support with `css: { modules: { classNameStrategy: 'non-scoped' } }`. Add alias resolution for test files to use same `@/` imports as main application. Configure watch mode to ignore node_modules and coverage directories, and enable reporter as both 'verbose' and 'html' for detailed test output.

45. Create `playwright.config.ts` with projects array for chromium, firefox, and webkit browsers, baseURL set to `http://localhost:3000`, and timeout of 30000ms per test. Configure webServer to run `npm run dev` before tests with reuseExistingServer option for faster local development. Set up test directory as `./tests`, reporter as both 'html' and 'list', and use retries: 2 for CI environment. Configure screenshot mode as 'only-on-failure', video recording as 'retain-on-failure', and trace collection as 'retain-on-failure'. Add global setup file `tests/global-setup.ts` for authentication state and database seeding before test runs.

46. Install Sentry error tracking with `npm install @sentry/react @sentry/tracing` and create environment variable `VITE_SENTRY_DSN` for Sentry project DSN key. Configure Sentry in main.tsx before React root creation with `Sentry.init()` including DSN, environment detection, and sample rates for performance monitoring. Set up error boundary component `ErrorBoundary` using Sentry's built-in boundary with custom fallback UI showing friendly error message and report button. Add user context tracking with `Sentry.setUser()` when authentication state changes, including user ID and email for error attribution. Configure breadcrumb tracking for navigation events, API calls, and user interactions with custom categories and severity levels.

47. Create `src/lib/sentry.ts` with Sentry initialization function accepting DSN from `import.meta.env.VITE_SENTRY_DSN` and environment detection using `import.meta.env.MODE`. Configure integrations array including `new BrowserTracing()` for performance monitoring and `new Replay()` for session replay on errors. Set up custom error filtering to ignore common non-critical errors like network timeouts and cancelled requests using `beforeSend` callback. Implement custom tags for route-based error grouping and add release version from package.json for deployment tracking. Export configured Sentry instance and helper functions for manual error reporting and performance measurement.

48. Update `tsconfig.json` compilerOptions with comprehensive path mapping: `"paths": { "@/*": ["src/*"], "@/components/*": ["src/components/*"], "@/hooks/*": ["src/hooks/*"], "@/utils/*": ["src/utils/*"], "@/types/*": ["src/types/*"], "@/lib/*": ["src/lib/*"] }`. Configure module resolution with `"moduleResolution": "bundler"`, `"allowSyntheticDefaultImports": true`, and `"esModuleInterop": true` for better import compatibility. Add strict type checking with `"strict": true`, `"noUnusedLocals": true`, `"noUnusedParameters": true`, and `"exactOptionalPropertyTypes": true`. Set up proper DOM and ES2022 support with lib array including `["DOM", "DOM.Iterable", "ES2022"]` and target as `"ES2022"` for modern JavaScript features.

49. Create `.env.example` file with comprehensive environment variable documentation including exact format for each variable and instructions for obtaining values. Include structure: `# Supabase Configuration`, `VITE_SUPABASE_URL=https://your-project.supabase.co`, `VITE_SUPABASE_ANON_KEY=your-anon-key`, `# Stripe Configuration`, `VITE_STRIPE_PUBLISHABLE_KEY=pk_test_your-publishable-key`, `# Google Maps Configuration`, `VITE_GOOGLE_MAPS_API_KEY=your-google-maps-api-key`, `# Sentry Configuration`, `VITE_SENTRY_DSN=https://your-sentry-dsn.ingest.sentry.io`. Add detailed comments explaining where to obtain each key and required permissions/scopes. Include production vs development key differences and security notes about never committing actual values.

50. Install concurrently with `npm install -D concurrently` and create advanced development scripts for running multiple processes simultaneously. Configure `"dev:all": "concurrently -n \"vite,tsc,test\" -c \"blue,yellow,green\" \"npm run dev\" \"npm run type-check -- --watch\" \"npm run test -- --watch\""` to run Vite dev server, TypeScript compiler in watch mode, and Vitest in watch mode with colored output. Add `"dev:backend": "concurrently \"supabase start\" \"npm run dev\""` for local Supabase development. Create `"preview:full": "npm run build && concurrently \"npm run preview\" \"npm run test:e2e\""` to build and run preview with e2e tests. Configure kill settings with `--kill-others-on-fail` flag to stop all processes if any fail.

## PROMPTS 51-60: Database & Auth

51. Open Supabase SQL Editor and execute `CREATE EXTENSION IF NOT EXISTS "uuid-ossp";` to enable UUID generation functions for primary keys across all tables. Verify extension installation with `SELECT * FROM pg_extension WHERE extname = 'uuid-ossp';` query and confirm uuid_generate_v4() function is available. Configure default UUID generation for all id columns using `DEFAULT uuid_generate_v4()` to ensure unique identifiers without client-side generation. Add comment `COMMENT ON EXTENSION "uuid-ossp" IS 'UUID generation functions for unique identifiers';` for documentation. Test UUID generation with `SELECT uuid_generate_v4();` to confirm proper installation and functionality.

52. Execute `CREATE EXTENSION IF NOT EXISTS "postgis";` in Supabase SQL Editor to enable spatial data types and functions for location-based features like service areas and route optimization. Verify PostGIS installation with `SELECT PostGIS_Version();` and confirm geometry and geography data types are available. Test spatial functionality with sample point creation: `SELECT ST_Point(-73.935242, 40.730610);` to validate coordinate system support. Add spatial reference system support with `SELECT spatial_ref_sys.srid FROM spatial_ref_sys WHERE srid = 4326;` for GPS coordinates. Configure PostGIS for performance with `SET postgis.gdal_enabled_drivers = 'GTiff PNG JPEG';` for raster support if needed.

53. Create users table with exact schema: `CREATE TABLE users ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), email VARCHAR(255) UNIQUE NOT NULL, full_name VARCHAR(255) NOT NULL, phone VARCHAR(20), role VARCHAR(20) NOT NULL DEFAULT 'crew_member', avatar_url TEXT, is_active BOOLEAN DEFAULT true, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW() );`. Add trigger for automatic updated_at timestamp: `CREATE OR REPLACE FUNCTION update_updated_at_column() RETURNS TRIGGER AS $$ BEGIN NEW.updated_at = NOW(); RETURN NEW; END; $$ language 'plpgsql';` then `CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();`. Add table comment: `COMMENT ON TABLE users IS 'System users including staff and administrators';`.

54. Add role constraint to users table with `ALTER TABLE users ADD CONSTRAINT users_role_check CHECK (role IN ('owner', 'admin', 'crew_lead', 'crew_member', 'office_staff'));` to enforce valid role values. Create enum type for better type safety: `CREATE TYPE user_role AS ENUM ('owner', 'admin', 'crew_lead', 'crew_member', 'office_staff');` then alter table to use enum: `ALTER TABLE users ALTER COLUMN role TYPE user_role USING role::user_role;`. Add constraint comment: `COMMENT ON CONSTRAINT users_role_check ON users IS 'Ensures role is one of valid staff positions';`. Verify constraint with test insert that should fail: `INSERT INTO users (email, full_name, role) VALUES ('test@test.com', 'Test User', 'invalid_role');`.

55. Create optimized email index with `CREATE UNIQUE INDEX idx_users_email ON users(email) WHERE email IS NOT NULL;` for fast authentication lookups and duplicate prevention. Add partial index for active users: `CREATE INDEX idx_users_active ON users(is_active) WHERE is_active = true;` to optimize common queries for active staff. Create composite index for role-based queries: `CREATE INDEX idx_users_role_active ON users(role, is_active);` for permission checking. Analyze index usage with `EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM users WHERE email = 'user@example.com';` to verify query plan uses index scan. Add index comments: `COMMENT ON INDEX idx_users_email IS 'Unique index for email authentication lookups';`.

56. Create role-based query optimization index: `CREATE INDEX idx_users_role ON users(role) INCLUDE (id, full_name, is_active);` to support role filtering with covered columns for avoiding table lookups. Add functional index for case-insensitive email searches: `CREATE INDEX idx_users_email_lower ON users(LOWER(email));` for flexible authentication. Create partial index for specific role queries: `CREATE INDEX idx_users_crew_active ON users(role, created_at) WHERE role IN ('crew_lead', 'crew_member') AND is_active = true;` for crew management dashboards. Test index effectiveness with `EXPLAIN ANALYZE SELECT * FROM users WHERE role = 'crew_lead' AND is_active = true;` and verify bitmap index scan usage.

57. Create customers table with comprehensive schema: `CREATE TABLE customers ( id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), user_id UUID REFERENCES users(id) ON DELETE SET NULL, first_name VARCHAR(100) NOT NULL, last_name VARCHAR(100) NOT NULL, email VARCHAR(255) UNIQUE, phone VARCHAR(20), billing_address_line1 TEXT, billing_address_line2 TEXT, billing_city VARCHAR(100), billing_state VARCHAR(50), billing_zip VARCHAR(10), customer_type VARCHAR(20) DEFAULT 'residential', status VARCHAR(20) DEFAULT 'active', tags TEXT[], notes TEXT, stripe_customer_id VARCHAR(100) UNIQUE, created_at TIMESTAMPTZ DEFAULT NOW(), updated_at TIMESTAMPTZ DEFAULT NOW() );`. Add updated_at trigger: `CREATE TRIGGER update_customers_updated_at BEFORE UPDATE ON customers FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();`. Add table comment: `COMMENT ON TABLE customers IS 'Customer records with billing information and account status';`.

58. Add foreign key constraint with proper cascading: `ALTER TABLE customers ADD CONSTRAINT fk_customers_user_id FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL ON UPDATE CASCADE;` to handle user deletions gracefully while preserving customer records. Create index on foreign key: `CREATE INDEX idx_customers_user_id ON customers(user_id);` for join performance. Add constraint validation: `ALTER TABLE customers VALIDATE CONSTRAINT fk_customers_user_id;` to ensure data integrity. Test cascade behavior with sample data: create test user and customer, then delete user to verify customer.user_id becomes NULL. Add constraint comment: `COMMENT ON CONSTRAINT fk_customers_user_id ON customers IS 'Links customer to assigned user, nullified on user deletion';`.

59. Add status constraint with `ALTER TABLE customers ADD CONSTRAINT customers_status_check CHECK (status IN ('active', 'inactive', 'archived'));` and customer type constraint: `ALTER TABLE customers ADD CONSTRAINT customers_type_check CHECK (customer_type IN ('residential', 'commercial', 'municipal'));`. Create enum types for consistency: `CREATE TYPE customer_status AS ENUM ('active', 'inactive', 'archived');` and `CREATE TYPE customer_type AS ENUM ('residential', 'commercial', 'municipal');`. Update table columns to use enums: `ALTER TABLE customers ALTER COLUMN status TYPE customer_status USING status::customer_status;` and `ALTER TABLE customers ALTER COLUMN customer_type TYPE customer_type USING customer_type::customer_type;`. Add partial index for active customers: `CREATE INDEX idx_customers_active ON customers(status, customer_type) WHERE status = 'active';`.

60. Create full-text search capability with GIN index: `CREATE INDEX idx_customers_search ON customers USING GIN (to_tsvector('english', COALESCE(first_name, '') || ' ' || COALESCE(last_name, '') || ' ' || COALESCE(email, '') || ' ' || COALESCE(phone, '')));` for comprehensive customer search. Add trigram extension for fuzzy matching: `CREATE EXTENSION IF NOT EXISTS pg_trgm;` then create trigram index: `CREATE INDEX idx_customers_trigram ON customers USING GIN ((first_name || ' ' || last_name) gin_trgm_ops);`. Create search function: `CREATE OR REPLACE FUNCTION search_customers(search_term TEXT) RETURNS TABLE(id UUID, full_name TEXT, email VARCHAR, phone VARCHAR, rank REAL) AS $$ BEGIN RETURN QUERY SELECT c.id, c.first_name || ' ' || c.last_name, c.email, c.phone, ts_rank(to_tsvector('english', c.first_name || ' ' || c.last_name || ' ' || COALESCE(c.email, '') || ' ' || COALESCE(c.phone, '')), plainto_tsquery('english', search_term)) FROM customers c WHERE to_tsvector('english', c.first_name || ' ' || c.last_name || ' ' || COALESCE(c.email, '') || ' ' || COALESCE(c.phone, '')) @@ plainto_tsquery('english', search_term) ORDER BY ts_rank DESC; END; $$ LANGUAGE plpgsql;`. Test search with `SELECT * FROM search_customers('john smith');`.